{"id": 25, "name": "Hieroglyphs", "ioi_id": "hieroglyphs", "subtask": "06-full", "question": "You are an expert competitive programmer. You will be given a problem statement, test case constraints and example test inputs and outputs. Please reason step by step about the solution, then provide a complete implementation in C++17. You should correctly implement the routine(s) described in Implementation Details, without reading or writing anything directly from stdin or to stdout, as input and output are passed through the implemented routines. Assume your code will be run on the OFFICIAL grader, and do not add a main, a sample grader, or any other functionality unless it has been explicitly requested.\nPut your final solution within a single code block: ```cpp\n<your code here>``` \n\n# Problem statement (Hieroglyphs)\nA team of researchers is studying the similarities between sequences of hieroglyphs.\nThey represent each hieroglyph with a non-negative integer.\nTo perform their study,\n they use the following concepts about sequences.\n\nFor a fixed sequence $A$,\n a sequence $S$ is called a **subsequence** of $A$\n if and only if $S$ can be obtained\n by removing some elements (possibly none) from $A$.\n\nThe table below shows some examples of subsequences of a sequence $A = [3, 2, 1, 2]$.\n\n| Subsequence    | How it can be obtained from $A$ |\n|----------------|---------------------------------|\n| [3, 2, 1, 2] | No elements are removed.\n| [2, 1, 2]     | [<s>3</s>, 2, 1, 2]\n| [3, 2, 2]     | [3, 2, <s>1</s>, 2]\n| [3, 2]         | [3, <s>2</s>, <s>1</s>, 2] or [3, 2, <s>1</s>, <s>2</s>]\n| [3]             | [3, <s>2</s>, <s>1</s>, <s>2</s>]\n| [ ]              | [<s>3</s>, <s>2</s>, <s>1</s>, <s>2</s>]\n\nOn the other hand, $[3, 3]$ or $[1, 3]$ are not subsequences of $A$.\n\nConsider two sequences of hieroglyphs, $A$ and $B$.\nA sequence $S$ is called a **common subsequence** of $A$ and $B$\n if and only if $S$ is a subsequence of both $A$ and $B$.\nMoreover, we say that a sequence $U$ is a **universal common subsequence** of $A$ and $B$\n if and only if the following two conditions are met:\n* $U$ is a common subsequence of $A$ and $B$.\n* Every common subsequence of $A$ and $B$ is also a subsequence of $U$.\n\nIt can be shown that any two sequences $A$ and $B$\n have at most one universal common subsequence.\n\nThe researchers have found two sequences of hieroglyphs $A$ and $B$.\nSequence $A$ consists of $N$ hieroglyphs\n and sequence $B$ consists of $M$ hieroglyphs.\nHelp the researchers compute\n a universal common subsequence of sequences $A$ and $B$,\n or determine that such a sequence does not exist.\n\n## Implementation details\n\nYou should implement the following procedure.\n\n```\nstd::vector&lt;int&gt; ucs(std::vector&lt;int&gt; A, std::vector&lt;int&gt; B)\n```\n\n* $A$: array of length $N$ describing the first sequence.\n* $B$: array of length $M$ describing the second sequence.\n* If there exists a universal common subsequence of $A$ and $B$,\n   the procedure should return an array containing this sequence.\n  Otherwise, the procedure should return $[-1]$\n   (an array of length $1$, whose only element is $-1$).\n* This procedure is called exactly once for each test case.\n\n## Constraints\n\n* $1 \\leq N \\leq 100\\,000$\n* $1 \\leq M \\leq 100\\,000$\n* $0 \\leq A[i] \\leq 200\\,000$ for each $i$ such that $0 \\leq i < N$\n* $0 \\leq B[j] \\leq 200\\,000$ for each $j$ such that $0 \\leq j < M$\n\n## Examples\n\n### Example 1\n\nConsider the following call.\n\n```\nucs([0, 0, 1, 0, 1, 2], [2, 0, 1, 0, 2])\n```\n\nHere, the common subsequences of $A$ and $B$ are the following:\n $[\\ ]$, $[0]$, $[1]$, $[2]$, $[0, 0]$, $[0, 1]$, $[0, 2]$, $[1, 0]$, $[1, 2]$, $[0, 0, 2]$, $[0, 1, 0]$, $[0, 1, 2]$, $[1, 0, 2]$ and $[0, 1, 0, 2]$.\n\nSince $[0, 1, 0, 2]$ is a common subsequence of $A$ and $B$, and\n all common subsequences of $A$ and $B$ are subsequences of $[0, 1, 0, 2]$,\n the procedure should return $[0, 1, 0, 2]$.\n\n### Example 2\n\nConsider the following call.\n\n```\nucs([0, 0, 2], [1, 1])\n```\n\nHere, the only common subsequence of $A$ and $B$ is the empty sequence $[\\ ]$.\nIt follows that the procedure should return an empty array $[\\ ]$.\n\n### Example 3\n\nConsider the following call.\n```\nucs([0, 1, 0], [1, 0, 1])\n```\n\nHere, the common subsequences of $A$ and $B$ are\n $[\\ ], [0], [1], [0, 1]$ and $[1, 0]$.\nIt can be shown that a universal common subsequence does not exist.\nTherefore, the procedure should return $[-1]$.\n\n## Sample Grader\n\nInput format:\n\n```\nN  M\nA[0]  A[1]  ...  A[N-1]\nB[0]  B[1]  ...  B[M-1]\n```\n\nOutput format:\n\n```\nT\nR[0]  R[1]  ...  R[T-1]\n```\n\nHere, $R$ is the array returned by `ucs` and $T$ is its length.\n\n## Execution limits\nYour solution will have 1.0 second(s) execution time and 2048 MB memory limit to solve each test case.\n\n## Starting code\nHere's your starting code with some skeleton/placeholder functionality:\n```cpp\n#include \"hieroglyphs.h\"\n#include <vector>\n\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B) {\n  return std::vector<int>();\n}\n\n```", "subtask_score": 42, "test_names": ["0-02", "0-03", "smallbin-06", "smallbin-08", "smallbin-09", "smallcnt3-01", "smallcnt3-02", "smallbin-01", "smallbin-02", "smallbin-03"], "generation": "```cpp\n#include<bits/stdc++.h>\n#include \"hieroglyphs.h\"\n\nusing namespace std;\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing ii = pair<int, int>;\n\nconst int ALPHABET_SIZE = 200001;\n\nbool is_subsequence(const vi& a, const vi& b) {\n    int j = 0;\n    for (int x : a) {\n        if (j < (int)b.size() && b[j] == x) {\n            j++;\n        }\n    }\n    return j == (int)b.size();\n}\n\nvi get_candidate(const vi& a, const vi& b) {\n    int n = a.size();\n    int m = b.size();\n\n    vi occ_a(ALPHABET_SIZE, 0);\n    vi occ_b(ALPHABET_SIZE, 0);\n    for (int i=0; i < n; ++i) {\n        occ_a[a[i]]++;\n    }\n    for (int i=0; i < m; ++i) {\n        occ_b[b[i]]++;\n    }\n\n    vi c;\n    queue<int> qa;\n    queue<int> qb;\n\n    for (int i=0; i < n; ++i) {\n        if (occ_a[a[i]] <= occ_b[a[i]]) {\n            qa.push(i);\n        }\n    }\n    for (int i=0; i < m; ++i) {\n        if (occ_a[b[i]] > occ_b[b[i]]) {\n            qb.push(i);\n        }\n    }\n\n    int i_a_curr = 0;\n    int i_b_curr = 0;\n    int i_a_next = 0;\n    int i_b_next = 0;\n    vi occ_a_curr = vi(occ_a);\n    vi occ_a_next = vi(occ_a);\n    vi occ_b_curr = vi(occ_b);\n    vi occ_b_next = vi(occ_b);\n\n    while(!qa.empty() && !qb.empty()) {\n        while(i_a_next < qa.front()) {\n            occ_a_next[a[i_a_next]]--;\n            i_a_next++;\n        }\n        while(i_b_next < qb.front()) {\n            occ_b_next[b[i_b_next]]--;\n            i_b_next++;\n        }\n\n        int x = a[i_a_next];\n        int y = b[i_b_next];\n\n        int occ_x = occ_a_next[x];\n        int occ_y = occ_b_next[y];\n\n        bool a_good = (occ_a_next[y] >= occ_y && occ_b_curr[x] > occ_b_next[x]);\n        bool b_good = (occ_b_next[x] >= occ_x && occ_a_curr[y] > occ_a_next[y]);\n\n        if (a_good && b_good) return {-1};\n        if (!a_good && !b_good) return {-1};\n\n        if(a_good) {\n            c.push_back(x);\n            qa.pop();\n            while(i_a_curr <= i_a_next) {\n                occ_a_curr[a[i_a_curr]]--;\n                i_a_curr++;\n            }\n            while(b[i_b_curr] != x) {\n                occ_b_curr[b[i_b_curr]]--;\n                i_b_curr++;\n            }\n            occ_b_curr[b[i_b_curr]]--;\n            i_b_curr++;\n        }\n        else {\n            c.push_back(y);\n            qb.pop();\n            while(i_b_curr <= i_b_next) {\n                occ_b_curr[b[i_b_curr]]--;\n                i_b_curr++;\n            }\n            while(a[i_a_curr] != y) {\n                occ_a_curr[a[i_a_curr]]--;\n                i_a_curr++;\n            }\n            occ_a_curr[a[i_a_curr]]--;\n            i_a_curr++;\n        }\n    }\n\n    while(!qa.empty()) {\n        c.push_back(a[qa.front()]);\n        qa.pop();\n    }\n    while(!qb.empty()) {\n        c.push_back(b[qb.front()]);\n        qb.pop();\n    }\n\n    return ((is_subsequence(a, c) && is_subsequence(b, c)) ? c : vi({-1}));\n}\n\nvi index_vector(const vi& a, const vi& b) {\n    int n = a.size();\n    int m = b.size();\n    vi v(m);\n    vi prev_occ_b(ALPHABET_SIZE, -1);\n    vvi a_occ(ALPHABET_SIZE);\n    for (int i=0; i < n; ++i) {\n        a_occ[a[i]].push_back(i);\n    }\n    for (int i=0; i < ALPHABET_SIZE; ++i) {\n        a_occ[i].push_back(n);\n    }\n    vector<ii> min_stack;\n    for (int i=0; i < m; ++i) {\n        if (prev_occ_b[b[i]] == -1) {\n            v[i] = a_occ[b[i]][0];\n        }\n        else {\n            int min_val = lower_bound(min_stack.begin(), min_stack.end(), ii(prev_occ_b[b[i]], -1))->second;\n            if (min_val < n) v[i] = *lower_bound(a_occ[b[i]].begin(), a_occ[b[i]].end(), min_val+1);\n            else v[i] = n;\n        }\n        while(!min_stack.empty() && min_stack.back().second >= v[i]) {\n            min_stack.pop_back();\n        }\n        min_stack.emplace_back(i, v[i]);\n        prev_occ_b[b[i]] = i;\n    }\n    return v; \n}\n\nvi reverse_index_vector(vi a, vi b) {\n    int n = a.size();\n    reverse(a.begin(), a.end());\n    reverse(b.begin(), b.end());\n    vi v = index_vector(a, b);\n    reverse(v.begin(), v.end());\n    for (int& x : v) x = n-1-x;\n    return v; \n}\n\nbool verify(const vi& a, const vi& b, const vi& c) {\n    if (c == vi({-1})) return false;\n    if (c == vi()) return true; \n    int n = a.size();\n    int m = b.size();\n    int l = c.size();\n\n    vi occ_a(ALPHABET_SIZE, 0);\n    vi occ_b(ALPHABET_SIZE, 0);\n    for (int i=0; i < n; ++i) {\n        occ_a[a[i]]++;\n    }\n    for (int i=0; i < m; ++i) {\n        occ_b[b[i]]++;\n    }\n\n    vi iva = index_vector(a, c);\n    vi ivb = index_vector(b, c);\n    vi riva = reverse_index_vector(a, c);\n    vi rivb = reverse_index_vector(b, c);\n\n    int cai = 0;\n    int cbi = 0;\n    vector<ii> a_stack;\n    vector<ii> b_stack;\n\n    for (int i=0; i < l; ++i) {\n        if (occ_a[c[i]] <= occ_b[c[i]]) {\n            while (a[cai] != c[i]) cai++;\n\n            while (!a_stack.empty() && a_stack.back().second <= rivb[i]) a_stack.pop_back();\n            a_stack.emplace_back(cai, rivb[i]);\n\n            while (!b_stack.empty() && b_stack.back().second < cai) b_stack.pop_back();\n            if (!b_stack.empty() && b_stack.back().first > ivb[i]) {\n                return false;\n            }\n\n            cai++;\n        }\n        else {\n            while (b[cbi] != c[i]) cbi++;\n\n            while (!b_stack.empty() && b_stack.back().second <= riva[i]) b_stack.pop_back();\n            b_stack.emplace_back(cbi, riva[i]);\n\n            while (!a_stack.empty() && a_stack.back().second < cbi) a_stack.pop_back();\n            if (!a_stack.empty() && a_stack.back().first > iva[i]) {\n                return false;\n            }\n\n            cbi++;\n        }\n    }\n    return true;\n}\n\nvector<int> ucs(vector<int> a, vector<int> b) {\n    vi c = get_candidate(a, b);\n    if (verify(a, b, c)) return c;\n    return {-1};\n}```\n"}
